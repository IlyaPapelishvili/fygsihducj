## Обращение с умными указателями с помощью `Deref` типажа

Реализация типа `Deref` позволяет настроить поведение *оператора* разыменования (оператор разыменования), `*` (отличается от умножения или оператора глобального подключения). Реализуя типаж `Deref` таким образом, что умный указатель может использоваться как обычная ссылка, вы можете писать код, который работает с ссылками и использовать этот код также с умными указателями .

Давайте сначала посмотрим, как работает оператор разыменования с обычными ссылками. Затем мы пытаемся определить пользовательский тип, который будет вести себя как `Box<T>` и посмотрим, почему оператор не работает как ссылка для нового объявленного типа. Дереф `Deref` возможным работу умных указателей аналогично ссылкам. *Затем мы приводим разборчивое приведение* (дереф принуждение) в Rust, и это позволяет работать с любыми ссылками или умными указателями.

> Примечание: есть большая разница между типом `MyBox<T>` , который мы собираемся создать и реальным `Box<T>` : наша версия не будет хранить свои данные в куче. Например, Дереф, `Deref` данные хранятся, чем поведение похоже на указатель.

### Следование указателем к значению с помощью оператора разыменования

Обычная ссылка является типичным указателем и хранится в каком-то месте. В листинге 15-6 мы создаем ссылку на значение `i32` и используем оператор разыменования, чтобы следовать по ссылке к данным:

<span class="filename">Файл: src / main.rs</span>

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

<span class="caption">Листинг 15-6: Использование оператора разыменования для следования по ссылке к значению <code>i32</code></span>

Переменная `x` содержит тип `i32` со значением `5`. Мы устанавливаем `y` равным ссылке на `x`. Мы можем утверждать, что `x` равно `5`. Тем не менее, если мы хотим сделать утверждение о значении `y` то, мы должны использовать оператор `*y`, чтобы проследовать по ссылке к значению, на которое она указывает (следовательно, *разыменовывает*). Как только мы разыменовываем `y`, у нас есть доступ к целочисленному значению `y`, на которое указывает ссылка и мы можем сравнить его с `5`.

Если бы мы попытались написать `assert_eq!(5, y);` , чтобы получить ошибку компиляции:

```text
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `std::cmp::PartialEq<&{integer}>` is not implemented for
  `{integer}`
```

Сравнение числа и ссылок на число не допускается. Мы должны использовать оператор разыменования, чтобы перейти по ссылке на значение.

### Использование `Box<T>` как ссылка

Можно переписать код в листинге 15-6, чтобы использовать `Box<T>` вместо ссылок; оператор разыменования будет работать, как показано в листинге 15-7:

<span class="filename">Файл: src / main.rs</span>

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

<span class="caption">Листинг 15-7: Использование оператора разыменования с типом <code>Box</code> <i32></i32></span>

Единственная разница между листингом 15-7 и листинг 15-6 состоит в том, что здесь мы устанавливаем `y` на экземпляре окна, указывающий на значении `x` , а не ссылка, указывающий на значении `x` . В последнем утверждении мы можем использовать оператор разыменования, чтобы проследовать за указателем коробчатого а так же, как мы это делали когда `y` была ссылкой. `Box<T>` , которая позволяет нам использовать оператор разыменования, определяющий наш собственный тип `Box` .

### Определение собственного умного указателя

Давайте создадим умный указатель, похожий на тип `Box<T>` Мы добавили возможность использовать оператор разыменования.

Тип `Box<T>` в результате определяется как структура кортежа с одним элементом, поэтому в листинге 15-8 аналогичным образом определяется `MyBox<T>` . Мы также определим функцию `new` , чтобы она соответствовала функции `new` , определённой в `Box<T>` .

<span class="filename">Файл: src / main.rs</span>

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

<span class="caption">Листинг 15-8: Определение типа <code>MyBox</code> <t></t></span>

Мы определяем структуру с именем `MyBox` и объявляем обобщённый параметр `T` , потому что мы хотим, чтобы наш тип хранил значения любого типа. Тип `MyBox` является структурным кортежа с одним элементом типа `T` `MyBox::new` принимает один параметр типа `T` и возвращает экземпляр `MyBox` , который содержит переданное значение.

Давайте попробуем добавить функцию `main` из листинга 15-7 в листинг 15-8 и изменить тип использования `MyBox<T>` , который мы определили вместо `Box<T>` . Код в листинге 15-9 не будет компилироваться, потому что Руст не знает, как разыменовывать `MyBox` .

<span class="filename">Файл: src / main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

<span class="caption">Листинг 15-9: Попытка использовать <code>MyBox<t data-md-type="raw_html"></t></code> таким же образом, как мы использовали ссылки и библиотечный <code>Box<t data-md-type="raw_html"></t></code></span>

Вот результат ошибки компиляции:

```text
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
```

Наш тип `MyBox<T>` не может быть разыменован, потому что мы не реализовали эту возможность. Чтобы включить разыменование с помощью оператора `*` , мы продаем типаж `Deref` .

### Трактование типа как ссылки магистрауя типаж `Deref`

Как было сказано в главе 10, для реализации типа необходимо предоставить реализацию требуемых методов типа. Типаж `Deref` , предоставляемая стандартная библиотека, требует от нас реализация одного метода с именем `deref` , который заимствует `self` и возвращает ссылку на внутренних данных. Листинг 15-10 содержит реализацию `Deref` , который мы добавляем в определение `MyBox` :

<span class="filename">Файл: src / main.rs</span>

```rust
use std::ops::Deref;

# struct MyBox<T>(T);
impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}
```

<span class="caption">Листинг 15-10: Реализация <code>Deref</code> для типа <code>MyBox</code> <t></t></span>

Синтаксис `type Target = T;` определяется связанный тип для использования у типажа `Deref` . Связанные типы - это совсем другое. мы рассмотрим их более подробно в главе 19.

В тело метода `deref` мы размещаем `&self.0` , так что метод `deref` возвращает ссылку на значение, к которому мы хотим получить доступ с помощью оператора `*` . Функция `main` в листинге 15-9, которая показывает `*` у `MyBox<T>` теперь компилируется и проходит утверждение теста!

Без типажа `Deref` компилятор может только разыменовывать `&` ссылки. Метод `deref` даёт компилятору возможность принимать значение любого типа, используя принцип `Deref` и вызывать метод `deref` чтобы получить ссылку `&` , которую он знает, как разыменовывать.

Когда мы ввели `*y` в листинге 15-9, Rust фактически выполнил за кулисами такой код:

```rust,ignore
*(y.deref())
```

Ржавчина заменяет оператор `*` вызов метод `deref` и затем простое разыменование, поэтому нам не нужно думать о том, нужно ли нам вызывать метод `deref` . Эта функция ржавчина позволяет писать код, который функционирует одинаково, независимо от того, есть ли у нас обычная ссылка или тип, реализующий типаж `Deref` .

Система владения является причиной того, что метод `deref` возвращает ссылку на значение и того что простое разыменование за круглыми скобками в коде `*(y.deref())` все ещё необходимо. Если метод `deref` возвратил бы значение напрямую, а не ссылку на значение, то значение было бы перемещено из кода `self` . `MyBox<T>` в этом случае или в особых случаях, когда используется оператор разыменования.

Обратите внимание, что оператор `*` заменён вызовом метода `deref` , а затем вызовом оператора `*` только один раз, каждый раз, когда мы используем `*` в коде. Поскольку замена оператора `*` не повторяется бесконечно, мы получаем данные типа `i32` , которые соответствуют `5` в `assert_eq!` листинга 15-9.

### Неявные разыменованные приведениями в практику и методы

*Разыменованное приведение* (Deref принуждение) - это удобство, которое Rust выполняет над аргументами функций и методов. Разыменованное приведение преобразует ссылку на исходном типе, реализующий типаж `Deref` , в ссылке на целевом типе, в который `Deref` может преобразовать исходный тип. Это происходит автоматически, когда мы передаем ссылку на значение функции или атрибута. Последовательность вызовов является `deref` условием.

Разное приведенное выше описание было добавлено в Rust, так что программистам, пишущим вызов функций и методов, не нужно добавлять множество явных ссылок и разыменований с использованием `&` и `*` . Функциональные возможности также позволяют писать больше кода, а также с умными указателями.

`MyBox<T>` в листинге 15-8, а также `Deref` добавленную в листинге 15-10. Листинг 15-11 показывает определение функции,

<span class="filename">Файл: src / main.rs</span>

```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
```

<span class="caption">Листинг 15-11: Функция <code>hello</code> имеющая параметр <code>name</code> типа <code>&str</code></span>

Можно вызвать функцию `hello` со срезом строки в качестве аргумента, например `hello("Rust");` , Разыменованное приведение делает возможным вызов `hello` со ссылкой на значение типа `MyBox<String>` , как показано в листинге 15-12.

<span class="filename">Файл: src / main.rs</span>

```rust
# use std::ops::Deref;
#
# struct MyBox<T>(T);
#
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
#
# impl<T> Deref for MyBox<T> {
#     type Target = T;
#
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
#
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
#
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

<span class="caption">Листинг 15-12: Вызов <code>hello</code> со ссылкой на значение <code>MyBox</code> <string></string> , которое работает из-за разыменованного приведения</span>

Здесь мы вызываем функцию `hello` с аргументом `&m`, который является ссылкой на значение `MyBox<String>`. Поскольку мы реализовали типаж `Deref` для `MyBox<T>` в листинге 15-10, то Rust может преобразовать `&MyBox<String>` в `&String` вызывая `deref`. Стандартная библиотека предоставляет реализацию типажа `Deref` для типа `String`, которая возвращает срез строки, это описано в документации API типажа `Deref`. Rust снова вызывает `deref`, чтобы превратить `&String` в `&str`, что соответствует определению функции `hello`.

Если бы не было реализовано разное приведенное выше, мы должны были бы написать код в листинге 15-13 вместо кода в листинге 15-12 для вызова символа `hello` со значением типа `&MyBox<String>` .

<span class="filename">Файл: src / main.rs</span>

```rust
# use std::ops::Deref;
#
# struct MyBox<T>(T);
#
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
#
# impl<T> Deref for MyBox<T> {
#     type Target = T;
#
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
#
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
#
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

<span class="caption">Лист 15-13: Код, который мы должны были написать.</span>

Код `(*m)` разыменовывает `MyBox<String>` в `String` . Затем `&` и `[..]` принимает строковый срез `String` , равная вся строка, чтобы соответствовать сигнатуре `hello` . Сложно читать, писать и понимать со всеми этими символами. Разыменованное приведение позволяет Rust обрабатывать эти преобразования для нас автоматически.

Когда типаж `Deref` определён для задействованных типов, Rust проанализирует типы и будет использовать `Deref::deref` столько раз, сколько необходимо, чтобы получить ссылку, соответствующую типу параметра. Количество раз, которое нужно вставить `Deref::deref` определяется во время компиляции, поэтому использование разницы

### Как разыменованное приведенное взаимодействует с изменяемостью

Подобно тому, как вы используете типаж `Deref` для переопределения оператора `*` у неизменяемых ссылок, вы можете использовать типаж `DerefMut` для переопределения оператора `*` у изменяемых ссылок.

Rust выполняет разыменованное приведенное выше описание:

- Из типа `&T` в типе `&U` когда верно `T: Deref<Target=U>`
- Из типа `&mut T` в тип `&mut U` когда верно `T: DerefMut<Target=U>`
- Из типа `&mut T` в типе `&U` когда верно `T: Deref<Target=U>`

Первые два случая одинаковы за исключением изменяемости. В первом случае говорится, что если у вас есть тип `&T` , а `T` реализует типаж `Deref` для некоторого типа `U` , вы можете прозрачно получить `&U` . Во втором случае утверждается, что это сделано для измененных ссылок.

Третий случай хитрее: Rust также приводит изменяемую ссылку к неизменяемой. *Но обратное не представляется возможным:* неизменяемые ссылки никогда не приводятся к изменяемым ссылкам. Эта изменяемая ссылка должна быть единственной ссылкой на данные. Преобразование одной изменяемой ссылки в неизменяемую ссылку никогда не нарушает правила заимствования. Преобразование неизменяемой ссылки в измененную ссылку. Следовательно, Rust не может сделать предположение, что преобразование неизменяемой ссылки в изменяемую ссылку возможно.
