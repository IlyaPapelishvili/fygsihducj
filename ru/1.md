## Treating Smart Pointers Like Regular References with the `Deref` Trait

Implementing the `Deref` trait allows you to customize the behavior of the *dereference operator*, `*` (as opposed to the multiplication or glob operator). By implementing `Deref` in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.

Давайте сначала посмотрим, как работает оператор разыменования с обычными ссылками. Затем мы попытаемся определить пользовательский тип, который ведет себя как `Box<T>` , и посмотрим, почему оператор разыменования не работает как ссылка на наш новый определенный тип. Мы рассмотрим, как реализация черты `Deref` позволяет умным указателям работать аналогично ссылкам. Затем мы рассмотрим *функцию принудительного разглашения* в Rust и то, как она позволяет нам работать либо со ссылками, либо с умными указателями.

> Примечание: есть одно большое различие между `MyBox<T>` мы собираемся построить, и реальным `Box<T>` : наша версия не будет хранить свои данные в куче. Мы сосредоточим этот пример на `Deref` , поэтому, где данные на самом деле хранятся, менее важно, чем поведение, подобное указателю.

### После указателя на значение с помощью оператора разыменования

Обычная ссылка - это тип указателя, и один из способов представить указатель - это стрелка к значению, хранящемуся где-то еще. В листинге 15-6 мы создаем ссылку на значение `i32` а затем используем оператор разыменования, чтобы следовать ссылке на данные:

<span class="filename">Имя файла: src / main.rs</span>

```rust
fn main() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

<span class="caption">Listing 15-6: Using the dereference operator to follow a reference to an <code>i32</code> value</span>

Переменная `x` содержит значение `i32` , `5` . Мы устанавливаем `y` равным ссылке на `x` . Мы можем утверждать, что `x` равен `5` . Однако, если мы хотим сделать утверждение о значении в `y` , мы должны использовать `*y` чтобы следовать ссылке на значение, на которое оно указывает (следовательно, *разыменование* ). После разыменования `y` мы получаем доступ к целочисленному значению `y` , которое можно сравнить с `5` .

Если бы мы попытались написать `assert_eq!(5, y);` вместо этого мы получили бы эту ошибку компиляции:

```text
error[E0277]: can't compare `{integer}` with `&{integer}`
 --> src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &{integer}`
  |
  = help: the trait `std::cmp::PartialEq<&{integer}>` is not implemented for
  `{integer}`
```

Сравнение числа и ссылки на число не допускается, потому что они разных типов. Мы должны использовать оператор разыменования, чтобы следовать ссылке на значение, на которое он указывает.

### Использование `Box<T>` как ссылка

Мы можем переписать код в листинге 15-6, чтобы использовать `Box<T>` вместо ссылки; оператор разыменования будет работать, как показано в листинге 15-7:

<span class="filename">Имя файла: src / main.rs</span>

```rust
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

<span class="caption">Листинг 15-7. Использование оператора разыменования в <code>Box<i32></code></span>

Единственное отличие между листингом 15-7 и листингом 15-6 состоит в том, что здесь мы устанавливаем `y` как экземпляр блока, указывающего на значение в `x` а не ссылку, указывающую на значение `x` . В последнем утверждении мы можем использовать оператор разыменования, чтобы следовать за указателем блока так же, как мы делали, когда `y` был ссылкой. Далее мы рассмотрим, что особенного в `Box<T>` что позволяет нам использовать оператор разыменования, определяя наш собственный тип box.

### Определение нашего собственного умного указателя

Давайте создадим умный указатель, похожий на тип `Box<T>` предоставляемый стандартной библиотекой, чтобы понять, как умные указатели ведут себя иначе, чем ссылки по умолчанию. Затем мы рассмотрим, как добавить возможность использовать оператор разыменования.

Тип `Box<T>` в конечном итоге определяется как структура кортежа с одним элементом, поэтому в листинге 15-8 `MyBox<T>` определяется таким же образом. Мы также определим `new` функцию, чтобы соответствовать `new` функции, определенной в `Box<T>` .

<span class="filename">Имя файла: src / main.rs</span>

```rust
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
```

<span class="caption">Листинг 15-8. Определение типа <code>MyBox<T></code></span>

We define a struct named `MyBox` and declare a generic parameter `T`, because we want our type to hold values of any type. The `MyBox` type is a tuple struct with one element of type `T`. The `MyBox::new` function takes one parameter of type `T` and returns a `MyBox` instance that holds the value passed in.

Давайте попробуем добавить `main` функцию из листинга 15-7 в листинг 15-8 и изменить ее на использование типа `MyBox<T>` мы определили вместо `Box<T>` . Код в листинге 15-9 не будет компилироваться, потому что Rust не знает, как разыменовать `MyBox` .

<span class="filename">Имя файла: src / main.rs</span>

```rust,ignore,does_not_compile
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
```

<span class="caption">Листинг 15-9. Попытка использовать <code>MyBox<T></code> же, как мы использовали ссылки и <code>Box<T></code></span>

Вот итоговая ошибка компиляции:

```text
error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
  --> src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
```

Наш `MyBox<T>` не может быть разыменован, потому что мы не реализовали эту возможность в нашем типе. Чтобы включить разыменование с помощью оператора `*` , мы реализуем черту `Deref` .

### Обработка типа как ссылки путем реализации `Deref`

Как обсуждалось в главе 10, для реализации признака нам необходимо предоставить реализации для требуемых методов признака. Черта `Deref` , предоставляемая стандартной библиотекой, требует от нас реализации одного метода с именем `deref` который заимствует `self` и возвращает ссылку на внутренние данные. Перечисление 15-10 содержит реализацию `Deref` для добавления к определению `MyBox` :

<span class="filename">Имя файла: src / main.rs</span>

```rust
use std::ops::Deref;

# struct MyBox<T>(T);
impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}
```

<span class="caption">Листинг 15-10. Реализация <code>Deref</code> в <code>MyBox<T></code></span>

The `type Target = T;` syntax defines an associated type for the `Deref` trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don’t need to worry about them for now; we’ll cover them in more detail in Chapter 19.

We fill in the body of the `deref` method with `&self.0` so `deref` returns a reference to the value we want to access with the `*` operator. The `main` function in Listing 15-9 that calls `*` on the `MyBox<T>` value now compiles, and the assertions pass!

Без черты `Deref` компилятор может только разыменовывать `&` ссылаться. Метод `deref` дает компилятору возможность принимать значение любого типа, которое реализует `Deref` и вызывать метод `deref` чтобы получить ссылку `&` которую он знает, как разыменовать.

Когда мы ввели `*y` в листинге 15-9, за кулисами Rust фактически запустил этот код:

```rust,ignore
*(y.deref())
```

Rust substitutes the `*` operator with a call to the `deref` method and then a plain dereference so we don’t have to think about whether or not we need to call the `deref` method. This Rust feature lets us write code that functions identically whether we have a regular reference or a type that implements `Deref`.

The reason the `deref` method returns a reference to a value, and that the plain dereference outside the parentheses in `*(y.deref())` is still necessary, is the ownership system. If the `deref` method returned the value directly instead of a reference to the value, the value would be moved out of `self`. We don’t want to take ownership of the inner value inside `MyBox<T>` in this case or in most cases where we use the dereference operator.

Обратите внимание, что оператор `*` заменяется вызовом метода `deref` а затем вызовом оператора `*` только один раз, каждый раз, когда мы используем `*` в нашем коде. Поскольку замена оператора `*` не повторяется бесконечно, мы получаем данные типа `i32` , которые соответствуют `5` в `assert_eq!` в Перечислении 15-9.

### Неявное разыменное приведение с помощью функций и методов

*Принуждение по принуждению* - это удобство, которое Rust выполняет для аргументов функций и методов. Приведение Deref преобразует ссылку на тип, который реализует `Deref` в ссылку на тип, в который `Deref` может преобразовать исходный тип. Принуждение происходит автоматически, когда мы передаем ссылку на значение определенного типа в качестве аргумента функции или методу, который не соответствует типу параметра в определении функции или метода. Последовательность вызовов метода `deref` преобразует тип, который мы предоставили, в тип, в котором нуждается параметр.

Принуждение к разыменованию было добавлено в Rust, так что программистам, пишущим вызовы функций и методов, не нужно добавлять столько явных ссылок и разыменований с помощью `&` и `*` . Функция разыменования также позволяет нам писать больше кода, который может работать как для ссылок, так и для умных указателей.

Чтобы увидеть принудительное приведение в действие, давайте используем `MyBox<T>` мы определили в листинге 15-8, а также реализацию `Deref` которую мы добавили в листинге 15-10. В листинге 15-11 показано определение функции с параметром фрагмента строки:

<span class="filename">Имя файла: src / main.rs</span>

```rust
fn hello(name: &str) {
    println!("Hello, {}!", name);
}
```

<span class="caption">Листинг 15-11. Функция <code>hello</code> с <code>name</code> параметра типа <code>&str</code></span>

Мы можем вызвать функцию `hello` со срезом строки в качестве аргумента, например `hello("Rust");` например. Принуждение по вызову позволяет вызывать `hello` со ссылкой на значение типа `MyBox<String>` , как показано в листинге 15-12:

<span class="filename">Имя файла: src / main.rs</span>

```rust
# use std::ops::Deref;
#
# struct MyBox<T>(T);
#
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
#
# impl<T> Deref for MyBox<T> {
#     type Target = T;
#
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
#
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
#
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

<span class="caption">Листинг 15-12. Вызов <code>hello</code> со ссылкой на значение <code>MyBox<String></code> , которое работает из-за принудительного обращения</span>

Здесь мы вызываем функцию `hello` с аргументом `&m` , который является ссылкой на значение `MyBox<String>` . Поскольку мы реализована `Deref` черта на `MyBox<T>` в листинге 15-10, Ржавчина может включить `&MyBox<String>` в `&String` по телефону `deref` . Стандартная библиотека предоставляет реализацию `Deref` on `String` которая возвращает фрагмент строки, и это находится в документации API для `Deref` . Rust снова вызывает `deref` чтобы превратить `&String` в `&str` , что соответствует определению функции `hello` .

Если бы Rust не реализовал принудительное приведение, мы должны были бы написать код в листинге 15-13 вместо кода в листинге 15-12, чтобы вызвать `hello` со значением типа `&MyBox<String>` .

<span class="filename">Имя файла: src / main.rs</span>

```rust
# use std::ops::Deref;
#
# struct MyBox<T>(T);
#
# impl<T> MyBox<T> {
#     fn new(x: T) -> MyBox<T> {
#         MyBox(x)
#     }
# }
#
# impl<T> Deref for MyBox<T> {
#     type Target = T;
#
#     fn deref(&self) -> &T {
#         &self.0
#     }
# }
#
# fn hello(name: &str) {
#     println!("Hello, {}!", name);
# }
#
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

<span class="caption">Листинг 15-13. Код, который мы должны были бы написать, если бы у Rust не было разыскивания</span>

`(*m)` разыменовывает `MyBox<String>` в `String` . Затем `&` и `[..]` берут фрагмент `String` , равный всей строке, чтобы соответствовать сигнатуре `hello` . Код без непосредственного приведения сложнее читать, писать и понимать со всеми этими символами. Принуждение к конфликту позволяет Rust обрабатывать эти преобразования для нас автоматически.

When the `Deref` trait is defined for the types involved, Rust will analyze the types and use `Deref::deref` as many times as necessary to get a reference to match the parameter’s type. The number of times that `Deref::deref` needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!

### Как Deref Coercion взаимодействует с изменчивостью

Подобно тому, как вы используете черту `Deref` для переопределения оператора `*` в неизменяемых ссылках, вы можете использовать черту `DerefMut` для переопределения оператора `*` в изменяемых ссылках.

Rust разыскивает принудительное приведение, когда находит типы и реализации признаков в трех случаях:

- От `&T` до `&U` когда `T: Deref<Target=U>`
- От `&mut T` к `&mut U` когда `T: DerefMut<Target=U>`
- От `&mut T` к `&U` когда `T: Deref<Target=U>`

Первые два случая одинаковы за исключением изменчивости. В первом случае говорится, что если у вас есть `&T` , а `T` реализует `Deref` для некоторого типа `U` , вы можете прозрачно получить `&U` Во втором случае утверждается, что такое же принудительное приведение происходит для изменяемых ссылок.

Третий случай хитрее: Rust также принудительно изменяет ссылку на неизменяемый. Но обратное *не* представляется возможным: неизменные ссылки никогда не принуждать к изменяемых ссылок. Из-за правил заимствования, если у вас есть изменяемая ссылка, эта изменяемая ссылка должна быть единственной ссылкой на эти данные (в противном случае программа не будет компилироваться). Преобразование одной изменяемой ссылки в одну неизменную ссылку никогда не нарушит правила заимствования. Преобразование неизменяемой ссылки в изменяемую ссылку потребует наличия только одной неизменной ссылки на эти данные, и правила заимствования не гарантируют этого. Следовательно, Rust не может предположить, что преобразование неизменяемой ссылки в изменяемую ссылку возможно.
